
// ========================
// Code 1: Logic of the Robot
// ========================

#include "OpenCVArmorDetector.h"

void OpenCVArmorDetector::setConfig(DetectorConfig config)
{
    _config = config;

    // Set the color limits based on config
    _blue_lower_limit = cv::Scalar(105 - _config._hue_range_limit, _config._saturation_lower_limit, _config._value_lower_limit);
    _blue_upper_limit = cv::Scalar(105 + _config._hue_range_limit, 255, 255);
    _red_lower_limit_1 = cv::Scalar(0, _config._saturation_lower_limit, _config._value_lower_limit);
    _red_upper_limit_1 = cv::Scalar(_config._hue_range_limit, 255, 255);
    _red_lower_limit_2 = cv::Scalar(179 - _config._hue_range_limit, _config._saturation_lower_limit, _config._value_lower_limit);
    _red_upper_limit_2 = cv::Scalar(179, 255, 255);
    _purple_lower_limit = cv::Scalar(125, _config._saturation_lower_limit, _config._value_lower_limit);
    _purple_upper_limit = cv::Scalar(145, 255, 255);

    // Set the other config variables
    _targetColor = config._target_color;
    _max_missed_frames = config._max_missed_frames;
    _reduce_search_area = config._reduce_search_area;
}

std::vector<cv::Point2f> OpenCVArmorDetector::detectArmorsInFrame(cv::Mat &frame)
{
    cv::Mat hsvFrame, mask;
    cv::GaussianBlur(frame, frame, cv::Size(5, 5), 0);
    cv::cvtColor(frame, hsvFrame, cv::COLOR_BGR2HSV);

    // Apply appropriate color mask
    if (_targetColor == BLUE)
    {
        cv::inRange(hsvFrame, _blue_lower_limit, _blue_upper_limit, mask);
        cv::Mat purple_mask;
        cv::inRange(hsvFrame, _purple_lower_limit, _purple_upper_limit, purple_mask);
        cv::bitwise_and(mask, ~purple_mask, mask);
    }
    else
    {
        cv::Mat lower_red, upper_red;
        cv::inRange(hsvFrame, _red_lower_limit_1, _red_upper_limit_1, lower_red);
        cv::inRange(hsvFrame, _red_lower_limit_2, _red_upper_limit_2, upper_red);
        cv::bitwise_or(lower_red, upper_red, mask);
    }

    std::vector<std::vector<cv::Point>> contours;
    cv::findContours(mask, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

    std::vector<cv::RotatedRect> light_bars;
    for (const auto &contour : contours)
    {
        if (contour.size() > 20)
        {
            cv::RotatedRect rect = cv::minAreaRect(contour);
            if (isLightBar(rect))
                light_bars.push_back(rect);
        }
    }

    if (light_bars.size() >= 2)
    {
        for (size_t i = 0; i < light_bars.size() - 1; i++)
        {
            for (size_t j = i + 1; j < light_bars.size(); j++)
            {
                if (isArmor(light_bars[i], light_bars[j]))
                {
                    return rectToPoint(light_bars[i], light_bars[j]);
                }
            }
        }
    }
    return {};
}

std::vector<cv::Point2f> OpenCVArmorDetector::rectToPoint(cv::RotatedRect &rect)
{
    float rad = rect.angle < 90 ? rect.angle * M_PI / 180.f : (rect.angle - 180) * M_PI / 180.f;
    float x_offset = rect.size.height * std::sin(rad) / 2.f;
    float y_offset = rect.size.height * std::cos(rad) / 2.f;

    std::vector<cv::Point2f> points;
    points.push_back(cv::Point2f(int(rect.center.x + x_offset), int(rect.center.y - y_offset)));
    points.push_back(cv::Point2f(int(rect.center.x - x_offset), int(rect.center.y + y_offset)));
    return points;
}

// ========================
// Code 2: Backend Uses Libraries
// ========================

#include "OpenCVArmorDetectorNode.hpp"

OpenCVArmorDetectorNode::OpenCVArmorDetectorNode(const rclcpp::NodeOptions &options) : Node("opencv_armor_detector", options)
{
  RCLCPP_INFO(get_logger(), "OpenCVArmorDetectorNode has been started.");

  _hue_range_limit = this->declare_parameter("_hue_range_limit", 30);
  _saturation_lower_limit = this->declare_parameter("_saturation_lower_limit", 100);
  _value_lower_limit = this->declare_parameter("_value_lower_limit", 150);
  _target_color = this->declare_parameter("_target_red", true) ? RED : BLUE;
  _max_missed_frames = this->declare_parameter("_max_missed_frames", 1);
  _reduce_search_area = this->declare_parameter("_reduce_search_area", true);

  params_callback_handle_ = this->add_on_set_parameters_callback(std::bind(&OpenCVArmorDetectorNode::parameters_callback, this, std::placeholders::_1));
  keypoints_publisher = this->create_publisher<vision_msgs::msg::KeyPoints>("key_points", 10);

  DetectorConfig config = {_target_color, _hue_range_limit, _saturation_lower_limit, _value_lower_limit, _max_missed_frames, _reduce_search_area};
  detector = new OpenCVArmorDetector(config);
}

OpenCVArmorDetectorNode::~OpenCVArmorDetectorNode() { delete detector; }

int main(int argc, char *argv[])
{
  setvbuf(stdout, NULL, _IONBF, BUFSIZ);
  rclcpp::init(argc, argv);
  rclcpp::executors::SingleThreadedExecutor exec;
  const rclcpp::NodeOptions options;
  auto opencv_armor_detector_node =
      std::make_shared<OpenCVArmorDetectorNode>(options);
  exec.add_node(opencv_armor_detector_node);
  exec.spin();
  rclcpp::shutdown();
  return 0;
}

